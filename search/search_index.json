{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Riyaz Riyaz is a light-weight, self-hostable learning platform. This documentation is a developer guide for Riyaz.","title":"Riyaz"},{"location":"#riyaz","text":"Riyaz is a light-weight, self-hostable learning platform. This documentation is a developer guide for Riyaz.","title":"Riyaz"},{"location":"cli/","text":"Riyaz CLI Installation $ pip install riyaz Usage Create a new project template with riyaz new <project-dir> $ riyaz new alpha-course This will create a project structure like: alpha-course/ |-- course.yml |-- authors/ |-- |-- alice.md |-- module-1/ |-- |-- getting-started.md |-- module-2/ |__ |__ more-advanced-things.md You can see the course in action with: $ riyaz serve You can rename the modules and lessons, add/edit content, change the configuration in course.yml to use the new content. Then again when you want to check how the content wil appear on Riyaz, you can run riyaz serve and make final touchups. When you are ready to push it to the central repository (or another remote), you can run riyaz push . $ riyaz push TODO: Add a way to login","title":"Riyaz CLI"},{"location":"cli/#riyaz-cli","text":"","title":"Riyaz CLI"},{"location":"cli/#installation","text":"$ pip install riyaz","title":"Installation"},{"location":"cli/#usage","text":"Create a new project template with riyaz new <project-dir> $ riyaz new alpha-course This will create a project structure like: alpha-course/ |-- course.yml |-- authors/ |-- |-- alice.md |-- module-1/ |-- |-- getting-started.md |-- module-2/ |__ |__ more-advanced-things.md You can see the course in action with: $ riyaz serve You can rename the modules and lessons, add/edit content, change the configuration in course.yml to use the new content. Then again when you want to check how the content wil appear on Riyaz, you can run riyaz serve and make final touchups. When you are ready to push it to the central repository (or another remote), you can run riyaz push . $ riyaz push TODO: Add a way to login","title":"Usage"},{"location":"db/","text":"Riyaz Database Riyaz uses a simple schema-less, document database built on top of sqlite. The database is schema-less and it does not do any data integrity checks. The responsibility of data integraty is completely with the application using the database. Concepts The database is a collection of documents and each document contains three fields doctype, key and data. Document: - doctype: str - key: str - data: dict In addition to these fields, the database also maintains an id field which is used only for internal use. Usage The db module provides a base Document class. Here is the sample usage. one = Document(\"one\", {\"value\": 1, \"square\": 1, \"parity\": \"odd\"}).save() two = Document(\"two\", {\"value\": 2, \"square\": 4, \"parity\": \"even\"}).save() three = Document(\"three\", {\"value\": 3, \"square\": 9, \"parity\": \"odd\"}).save() doc = Document.find(key=\"one\") print(doc.key, doc.value) # one 1 doc = Document.find(square=4) print(doc.key, doc.value) # two 2 doc = Document.find_all() keys = [doc.key for doc in docs] print(keys) # ['one', 'two', 'three'] doc = Document.find_all(parity='odd') keys = [doc.key for doc in docs] print(keys) # ['one', 'three'] Please note that the fields in the data can be accessed directly from the doc . For example doc.value will give the value of doc.data['value'] . Models The db module supports creating your own model class for each doctype. For example, the following code creates a new model class for doctype number . from riyaz.db import Document, register_model class Number(Document): DOCTYPE = \"number\" register_model(Number) one = Number(\"one\", {\"value\": 1, \"square\": 1, \"parity\": \"odd\"}).save() two = Number(\"two\", {\"value\": 2, \"square\": 4, \"parity\": \"even\"}).save() three = Number(\"three\", {\"value\": 3, \"square\": 9, \"parity\": \"odd\"}).save() doc = Number.find(key=\"one\") print(doc.key, doc.value) # one 1 print(doc.doctype) # number print(type(doc)) # Number doc = Number.find(square=4) print(doc.key, doc.value) # two 2 doc = Number.find_all() keys = [doc.key for doc in docs] print(keys) # ['one', 'two', 'three'] doc = Number.find_all(parity='odd') keys = [doc.key for doc in docs] print(keys) # ['one', 'three'] Pros and Cons The following are the pros and cons of using this database. Pros: Very easy to use supports nested data very simple query interface Cons supports limited ways to query - for example, it is not possible use OR clause in queries no way to do joins no way to do count(*) queries and group by not possible to write raw sql","title":"Riyaz Database"},{"location":"db/#riyaz-database","text":"Riyaz uses a simple schema-less, document database built on top of sqlite. The database is schema-less and it does not do any data integrity checks. The responsibility of data integraty is completely with the application using the database.","title":"Riyaz Database"},{"location":"db/#concepts","text":"The database is a collection of documents and each document contains three fields doctype, key and data. Document: - doctype: str - key: str - data: dict In addition to these fields, the database also maintains an id field which is used only for internal use.","title":"Concepts"},{"location":"db/#usage","text":"The db module provides a base Document class. Here is the sample usage. one = Document(\"one\", {\"value\": 1, \"square\": 1, \"parity\": \"odd\"}).save() two = Document(\"two\", {\"value\": 2, \"square\": 4, \"parity\": \"even\"}).save() three = Document(\"three\", {\"value\": 3, \"square\": 9, \"parity\": \"odd\"}).save() doc = Document.find(key=\"one\") print(doc.key, doc.value) # one 1 doc = Document.find(square=4) print(doc.key, doc.value) # two 2 doc = Document.find_all() keys = [doc.key for doc in docs] print(keys) # ['one', 'two', 'three'] doc = Document.find_all(parity='odd') keys = [doc.key for doc in docs] print(keys) # ['one', 'three'] Please note that the fields in the data can be accessed directly from the doc . For example doc.value will give the value of doc.data['value'] .","title":"Usage"},{"location":"db/#models","text":"The db module supports creating your own model class for each doctype. For example, the following code creates a new model class for doctype number . from riyaz.db import Document, register_model class Number(Document): DOCTYPE = \"number\" register_model(Number) one = Number(\"one\", {\"value\": 1, \"square\": 1, \"parity\": \"odd\"}).save() two = Number(\"two\", {\"value\": 2, \"square\": 4, \"parity\": \"even\"}).save() three = Number(\"three\", {\"value\": 3, \"square\": 9, \"parity\": \"odd\"}).save() doc = Number.find(key=\"one\") print(doc.key, doc.value) # one 1 print(doc.doctype) # number print(type(doc)) # Number doc = Number.find(square=4) print(doc.key, doc.value) # two 2 doc = Number.find_all() keys = [doc.key for doc in docs] print(keys) # ['one', 'two', 'three'] doc = Number.find_all(parity='odd') keys = [doc.key for doc in docs] print(keys) # ['one', 'three']","title":"Models"},{"location":"db/#pros-and-cons","text":"The following are the pros and cons of using this database. Pros: Very easy to use supports nested data very simple query interface Cons supports limited ways to query - for example, it is not possible use OR clause in queries no way to do joins no way to do count(*) queries and group by not possible to write raw sql","title":"Pros and Cons"}]}